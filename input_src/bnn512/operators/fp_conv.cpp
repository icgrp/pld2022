#include "../host/typedefs.h"
const unsigned int fp_conv_wt[] = {0xf572028c,
0xf8dc018a,
0xdbd60113,
0x01e4ef45,
0xfe4e0270,
0xe981fe48,
0x005b10a9,
0xfe74ffac,
0x01a4ff4e,
0xd6cef3ff,
0x02840207,
0xfd994490,
0x001f007a,
0xf233ff34,
0x2873ffc5,
0x012800a1,
0x00571cdf,
0x00290730,
0x0077fed0,
0x2a63feeb,
0xfd13dac6,
0xfd5ff4d6,
0x200e01db,
0xffe9fe9c,
0x021af3fa,
0x4870fd98,
0xad8203af,
0x11db02f0,
0x03ec00dc,
0x16951244,
0x0141ff36,
0xfdcefff2,
0x04e9ffb0,
0xfeb9002a,
0xfaed0015,
0x0516f822,
0x0124fcb9,
0xffe900be,
0x1318029c,
0x00e5ffcb,
0xfe0eff8f,
0x017ff117,
0x0ecf3094,
0x01051e3e,
0xffb8ff33,
0xf441f99f,
0xff9a07d8,
0xfff910b7,
0x01da0226,
0x0152e3b4,
0x00fd0156,
0x0188ff4d,
0xfe4002a6,
0x009d0357,
0x0350ffb8,
0x01e5fa78,
0x021b02a8,
0xffe00147,
0x1263fd0d,
0x045b0309,
0xf9fa52ee,
0xfeb5ffc1,
0x1d6b00ab,
0x06180803,
0x339f4e67,
0xd3c40392,
0xb52bc13c,
0x4ee33590,
0x2f9d4c18,
0x73b58536,
0xb9efb55e,
0x4b6111c5,
0xb3ce1e15,
0x733fda74,
0x31c74a70,
0xe036cf89,
0xd11b1fde,
0xecb91dd6,
0x5e88b9d1,
0x43954f81,
0xd3ea4f81,
0xde6ef986,
0x3efa2d72,
0x9bf903ef,
0x43df1470,
0x439bfe42,
0xf14e63cd,
0x7328c16b,
0xc3ff687e,
0xfa6e562c,
0x34ec3af7,
0xcb0676df,
0xa3fefeb5,
0xae4df817,
0x5f6b9a19,
0xb936d93f,
0xf959d537,
0xbf2d467c,
0xebd1a62a,
0xbf1ff352,
0x79bb63b8,
0xef13afc0,
0x0bbecdb5,
0x2d67270c,
0xf463e2e7,
0xc6c88625,
0xacd385dc,
0x38bdc8fe,
0x726dcca5,
0xea09ed79,
0xc0ce6b9c,
0x15c4358d,
0x77246cbb,
0xfe397ed1,
0x642ec8ce,
0x572e12c0,
0x9761c2c7,
0xc7bccf17,
0x74f8ecad,
0x3de4d8ff,
0xd320618f,
0x793b3e39,
0xbde145ee,
0x33cfb8fb,
0xaf647862,
0x9c6aaa73,
0xe6739a5e,
0x1e01c49f,
0x00000000,
0x0259acd2,
0x00000000,
0x02ef61b0,
0x00000000,
0x04b65bc9,
0x00000000,
0x069b48a7,
0x00000000,
0x013cc9e4,
0x00000000,
0x04e67329,
0x00000000,
0x013c0e4f,
0x00000000,
0x0013fe0f,
0x00000000,
0x0791c24f,
0x00000000,
0x036591d8,
0x00000000,
0x043e9dc8,
0x00000000,
0x06918a0f,
0x00000000,
0x016a3536,
0x00000000,
0x03350ba5,
0x00000000,
0x00bc1e0f,
0x00000000,
0x06331a8d,
0x00000000,
0x01d801ff,
0x00000000,
0x061c03c9,
0x00000000,
0x047a351a,
0x00000000,
0x058ec763,
0x00000000,
0x03fffc04,
0x00000000,
0x0271389e,
0x00000000,
0x012bbe4a,
0x00000000,
0x03271b27,
0x00000000,
0x04b61b2d,
0x00000000,
0x0786c327,
0x00000000,
0x01389dc8,
0x00000000,
0x06c3661b,
0x00000000,
0x0691da4d,
0x00000000,
0x043a1fc8,
0x00000000,
0x07ff6a00,
0x00000000,
0x07a00847,
0x00000000,
0x072793c9,
0x00000000,
0x013a9dcc,
0x00000000,
0x03c3ec36,
0x00000000,
0x049e5369,
0x00000000,
0x0168f534,
0x00000000,
0x007c3e1f,
0x00000000,
0x013c99ec,
0x00000000,
0x009e4f27,
0x00000000,
0x07fc0141,
0x00000000,
0x03603c1e,
0x00000000,
0x049c4927,
0x00000000,
0x04d078d9,
0x00000000,
0x03258ba4,
0x00000000,
0x034ba437,
0x00000000,
0x00be5bc8,
0x00000000,
0x00dc4e27,
0x00000000,
0x071880ff,
0x00000000,
0x07ec71fd,
0x00000000,
0x0003be9f,
0x00000000,
0x074ba417,
0x00000000,
0x07270b27,
0x00000000,
0x0743a1d8,
0x00000000,
0x027578dc,
0x00000000,
0x07e3f1fc,
0x00000000,
0x00180fff,
0x00000000,
0x00d9fcd8,
0x00000000,
0x07c16233,
0x00000000,
0x04d86c76,
0x00000000,
0x0369ac36,
0x00000000,
0x01b4d8ec,
0x00000000,
0x02d16ad9,
0x00000000,
0x00da6df0,
0x00000000,
0x02371b85,
0x00000000,
0x0760303f,
0x00000000,
0x04ea345a,
0x00000000,
0x046e370b,
0x00000000,
0x016c363b,
0x00000000,
0x013d9de4,
0x00000000,
0x04d8e45a,
0x00000000,
0x036db601,
0x00000000,
0x05a6532d,
0x00000000,
0x0741ac17,
0x00000000,
0x01b0d86c,
0x00000000,
0x01b0fa6c,
0x00000000,
0x00be51e8,
0x00000000,
0x03633c1e,
0x00000000,
0x043e1bc9,
0x00000000,
0x0743a1f0,
0x00000000,
0x069b49e4,
0x00000000,
0x065b259a,
0x00000000,
0x03198cd6,
0x00000000,
0x006e73b4,
0x00000000,
0x000a6db2,
0x00000000,
0x036c92d9,
0x00000000,
0x01ee772b,
0x00000000,
0x0683ee27,
0x00000000,
0x0361f05c,
0x00000000,
0x04da61f0,
0x00000000,
0x0194cbe1,
0x00000000,
0x04cae453,
0x00000000,
0x009e5e27,
0x00000000,
0x005dadd0,
0x00000000,
0x046c361b,
0x00000000,
0x02974ac9,
0x00000000,
0x009e4be0,
0x00000000,
0x006d67b0,
0x00000000,
0x06371a8d,
0x00000000,
0x03371ba4,
0x00000000,
0x0662341b,
0x00000000,
0x06371b8c,
0x00000000,
0x053a8d4e,
0x00000000,
0x012f9da4,
0x00000000,
0x04ba9dca,
0x00000000,
0x03350ba5,
0x00000000,
0x02657bb0,
0x00000000,
0x07a2522f,
0x00000000,
0x01349e0f,
0x00000000,
0x059bc4cb,
0x00000000,
0x05a6512f,
0x00000000,
0x0791c8cd,
0x00000000,
0x01a4fb64,
0x00000000,
0x060f2783,
0x00000000,
0x059ac74b,
0x00000000,
0x02d17ad8,
0x00000000,
0x034f25b2,
0x00000000,
0x03e1b0f8,
0x00000000,
0x060f0793,
0x00000000,
0x07c36037,
0x00000000,
0x00bcd9e8,
0x00000000,
0x03c0e237,
0x00000000,
0x07fc01c2,
0x00000000,
0x026c139b,
0x00000000,
0x0523be49,
0x00000000,
0x005f2fd0,
0x00000000,
0x0733190f,
0x00000000,
0x07f800ff};

template<typename T>
static void load_kh(T& comp, const Word kh_mem[KH_WORDS], Address idx) {
  //printf("kh_mem %d\n", (unsigned int)idx/KH_PER_WORD);
  Word kh_word = kh_mem[idx/KH_PER_WORD];
  IdxType off = idx % KH_PER_WORD;
  if (off == 0)
    comp(15,0) = kh_word(15, 0);
  else if (off == 1)
    comp(15,0) = kh_word(31,16);
  else if (off == 2)
    comp(15,0) = kh_word(47,32);
  else
    comp(15,0) = kh_word(63,48);
}


void fp_conv(
	hls::stream< bit32 > & Input_1,
	hls::stream< bit32 > & Output_1
) {
#pragma HLS INTERFACE axis register port=Output_1
#pragma HLS INTERFACE axis register port=Input_1
  bit32 out_tmp;
  const unsigned M = 3;
  const unsigned S = 32;
  const unsigned OUTWORDS = 16; // words per output image
  Word kh_mem[KH_WORDS];
#pragma HLS ARRAY_PARTITION variable=kh_mem complete dim=1
  C1InputType win[M][K][K];
#pragma HLS ARRAY_PARTITION variable=win complete dim=0
  C1InputType lbuf[M][K-1][S];
//#pragma HLS ARRAY_PARTITION variable=lbuf complete dim=0
  Word outwords[OUTWORDS];
#pragma HLS ARRAY_PARTITION variable=outwords complete dim=0
  WtType wtbuf[M];
#pragma HLS ARRAY_PARTITION variable=wtbuf complete dim=0

  Address wt_offset = 0;
  ap_uint<3> wt_addr = 0;

  ap_uint<1> d_i_idx = 1;
  ap_uint<1> d_o_idx = 0;
  Address kh_index = 0;
  Address o_index = 0;
  const unsigned N = 128; // output fmap numbers 32x32bitsx128
  Word dmem[2][CONVOLVERS][C_DMEM_WORDS];
#pragma HLS ARRAY_PARTITION variable=dmem complete dim=2
#pragma HLS ARRAY_PARTITION variable=dmem complete dim=1

  int wt_cnt=KH_WORDS*2;

#ifdef RISCV
  static int cnt = 0;
  print_str("cnt = ");
  print_dec(cnt);
  print_str("\n");
  cnt++;
#endif

  fp_data_in: for(int in_data_cnt=0; in_data_cnt<1024; in_data_cnt++) {
#pragma HLS PIPELINE II=1
	Word in_dmp;
	in_dmp(31,  0) = Input_1.read();
	in_dmp(63, 32) = Input_1.read();
    dmem[1][0][in_data_cnt] = in_dmp;
  }


  for(int kh_i=0; kh_i<KH_WORDS; kh_i++)
  {
  	kh_mem[kh_i](63, 32) = fp_conv_wt[kh_i*2];
  	kh_mem[kh_i](31,  0) = fp_conv_wt[kh_i*2+1];
  	//printf("0x%08x,\n0x%08x,\n", (unsigned int) kh_mem[kh_i](63,32), (unsigned int) kh_mem[kh_i](31,0));
  }

  // Parallelized across m, better for HLS
  LOOP_FP_CONV_O:
  for (int n = 0; n < N; n++) {
#pragma HLS LOOP_TRIPCOUNT min=1 max=32
#ifdef RISCV
  print_str("n=");
  print_dec(n);
  print_str("\n");
#endif

    // clear linebuffers for each new output map
    LOOP_RESET_LINEBUFFERS:
    for (IdxType m = 0; m < M; m++) {
#pragma HLS UNROLL region
#pragma HLS UNROLL
      PROLOG_COLS: for (IdxType c = 0; c < S; c++) {
        PROLOG_ROWS: for (IdxType r = 0; r < K/2; r++) {
          for (IdxType lr = 0; lr < K-2; lr++) {
            lbuf[m][lr][c] = lbuf[m][lr+1][c];
          }
          lbuf[m][K-2][c] = 0;
      } }
    }



    // The weights for the 1st conv layer are just laid out
    // linearly across wt_mem, 3 weights per 64-bit word

    Word wt_word;
    wt_word(63, 32) =  fp_conv_wt[wt_cnt];//wt_mem[n % CONVOLVERS][n / CONVOLVERS];
    wt_cnt++;
    wt_word(31,  0) =  fp_conv_wt[wt_cnt];//wt_mem[n % CONVOLVERS][n / CONVOLVERS];
    //printf("0x%08x,\n0x%08x,\n", (unsigned int) wt_word(63,32), (unsigned int) wt_word(31,0));
    wt_cnt++;
    LOOP_LOAD_WTS:
    for (ap_uint<2> m = 0; m < M; m++) {
#pragma HLS UNROLL
      wtbuf[m](8, 0) = wt_word((m+1)*WT_SIZE-1, m*WT_SIZE);
    }

    // load batch norm params
    C1Comp nc;




    load_kh(nc, kh_mem, (kh_index+n));
    //printf ("  n=%3d, nc=%6.3f\n", n.to_int(), nc.to_float());

    // begin convolution
    LOOP_CONV_ROWS: for (IdxType r = 0; r < S+1; r++) {
      LOOP_CONV_COLS: for (IdxType c = 0; c < S+1; c++) {
#pragma HLS PIPELINE
        // load input word
        Word inword = 0;
        if (r < S && c < S) {
          Address addr = r*S + c;
          inword = dmem[d_i_idx][addr/C_DMEM_WORDS][addr%C_DMEM_WORDS];
        }

        for (ap_uint<2> m = 0; m < M; m++) {
          // load data: the value of pix is either the pixel at [r,c]
          // 0 -> +1, -1 -> -1
          // or -> 0 for padding around the boundaries
          C1InputType pix;
          const unsigned W = 20;
          pix(W-1,0) = inword(W-1+m*W, m*W);

          // window: shift left, leaving rightmost col for new data
          for (IdxType wr = 0; wr < K; wr++) {
            for (IdxType wc = 0; wc < K-1; wc++) {
              win[m][wr][wc] = win[m][wr][wc+1];
          } }

          // window: fill top K-1 pixels of rightmost column from lbuf
          for (IdxType wr = 0; wr < K-1; wr++) {
            C1InputType val = (c != S) ? lbuf[m][wr][c] : C1InputType(0);
            win[m][wr][K-1] = val;
          }

          // window: fill bottom right with new input pixel
          win[m][K-1][K-1] = pix;

          // lbuf: shift up column c
          if (c != S) {
            for (IdxType lr = 0; lr < K-2; lr++) {
              lbuf[m][lr][c] = lbuf[m][lr+1][c];
            }
            lbuf[m][K-2][c] = pix;
          }
        } // m

        // only perform the conv and store if legal position
        if (r > 0 && c > 0) {
          C1ConvType res = 0;
          for (ap_uint<2> m = 0; m < M; m++) {
            for (ap_uint<2> wr = 0; wr < K; wr++) {
              for (ap_uint<2> wc = 0; wc < K; wc++) {
                //const C1InputType& pix = win[m][wr][wc];
            	C1InputType pix;
            	pix = win[m][wr][wc];
                //const Bit& b = wtbuf[m][8-(wr*K+wc)];
            	Bit b;
            	b(0, 0) = wtbuf[m](8-(wr*K+wc),8-(wr*K+wc)) ;
                res = res + ((b==0) ? pix : (C1InputType)(-pix));
            } }
          }

          // perform normalization right here
          outwords[(r-1)/2](((r-1)%2)*S + (c-1), ((r-1)%2)*S + (c-1)) =
            (res >= nc) ? Bit(0) : Bit(-1);
        }

      } // CONV_COLS
    } // CONV_ROWS

    // Here i is the word offset within the outwords buffer
    LOOP_OUTPUT:
    for (IdxType i = 0; i < OUTWORDS; i++) {
#pragma HLS PIPELINE
      Address img_idx = o_index+n;
      Address bank_idx = img_idx % CONVOLVERS;
      Address bank_off = img_idx / CONVOLVERS;
      dmem[d_o_idx][bank_idx][bank_off*OUTWORDS + i] = outwords[i];
      //printf("d_o_idx = %d, bank_idx = %d, bank_off*OUTWORDS + i = %d\n",
      //        		  (unsigned int)(d_o_idx),
      //				  (unsigned int)(bank_idx),
      //				  (unsigned int)(bank_off*OUTWORDS + i));
    }
  } // n

  //for(unsigned int dmem_i=0; dmem_i<2; dmem_i++)
  for(unsigned int dmem_j=0; dmem_j<CONVOLVERS; dmem_j++)
    for(unsigned int dmem_k=0; dmem_k<C_DMEM_WORDS; dmem_k++){
      out_tmp(31, 0) = dmem[0][dmem_j][dmem_k](31,  0);
      Output_1.write(out_tmp);
      out_tmp(31, 0) = dmem[0][dmem_j][dmem_k](63, 32);
      Output_1.write(out_tmp);
    }

}
